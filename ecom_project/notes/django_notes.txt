Django setup  (after env configuration):
1. activate virtual/conda env
2. Go to the desired directory
3. run: django-admin startproject project_name
4. cd into project folder
5. run : python manage.py runserver

Model View Template pattern

6. Connect urls to views
7. Templates : Create a folder template

Static files :
python manage.py collectstatic

Working with apps :
8. python manage.py startapp app_name
9. settings.py add the app in INSTALLED_APPS
10. include new app url in project urls.py
11. connect new app url with its views.py file
12. Create a template to render app reponses

Link project template to app named path
13. In new app urls file create a variable app_name = 'app_users'
14. In project template 'app_users:user_list'

Models -> Interact with Databases to interact with dynamic data
(Within the app you want to use to manage this type of object)
15. models.py : We should create a class which attributes will be stored as columns in our databases
16. Excecute migrations : python manage.py makemigrations

Admin panel :
17. python manage.py createsuperuser
18. Go to "http://127.0.0.1:8000/admin"
19. Register apps you'd like to manage from you app / admin

Connect app with db:
20. our_app views.py clas.object.all()

We will add functionalities by creating apps :
21. python manage.py startapp app_category, app_users, app_products ..
21.1 settings.py add app
22. Within our new app , create a Model / register in new_app/admin.py
22.1 python manage.py migrate , python manage.py makemigrations

-- fix --
In Django, the verbose_name attribute is used to specify the human-readable name for a model field or model itself.
The verbose_name_plural attribute is similar, but specifies the name to use for the model in the plural form.
These attributes are important because they allow you to specify more descriptive and user-friendly names for your models and fields
(That's why in our apps where we use "Class" to refer to the model, we need to set this properties in readable value)
Migrate and make migrations after that

Users and Logins:
built-in authentication and authorization system
Django's user management features allow you to easily create user accounts, handle password resets, and track user activity
(But its requieres user name, we want email.. lets change it)
23: Create a new_app (app_accounts)
23.1 : settings.py add app

The date_joined field in Django's AbstractBaseUser model is used to store the date and time that the user account was created. This can be useful for tracking user activity and analyzing user behavior.
The last_login field is used to store the date and time of the user's most recent login. This can be useful for tracking user activity and identifying inactive users.
The is_admin, is_staff, and is_superuser fields are used to indicate the user's level of access and permissions.
The is_admin field is typically used to designate users who have administrative access to the site
The is_staff field is used to designate users who have access to the site's backend but not necessarily full administrative access.
The is_superuser field is used to designate users who have full administrative access to the site.
The is_active field is used to indicate whether the user account is active or inactive.

23.2 After creating this app we need to define AUTH_USER_MODEL in settings.py

User admin panel:
24. app_accounts admin.py show nicer format (horizontal and linked)

Auto generate slug for category :
25. app_category admin.py

How to manage many products?
26. we will create a new app to do this -> app_product

Dynamic products in page :
27. home_view in project views will send a "context" dictionary which will be displayed in home.html with {% for product in products_all  %}

Creating Store section :
28. projects urls.py path('store/', include('app_store.urls')) and we create urls.py file in app_store. Then we send a info_to_render dictionary from app_store views (connected by urls.py -> app_store/urls.py) and render it with {% for loop %} in store_file.html

Filtering results
29. We want to show products from specific class: /store/data-science.
  In app_store.urls we create a path(<slug:category_slug>, views.store_view)
  In app_store.views we import CategoryClass from app_category and filter using :products_available = ProductClass.objects.filter(category=categories, is_available=True)

Categories Menu: Database query to list dynamic results
  Django function : context_processors.py
30. Create a file app_category/context_processors.py
    Register it in settings.py TEMPLATES-OPTIONS-context_processors : app_category.context_processors.menu_links
    This will allow any template in the project to access the info within menu_links function in context_processors
    We want to link each category with its url: we create a get_url function within CategoryClass model in app_category.models.
    This function will reverse our products_by_category_path in app_store.urls and add self.slug -> return sth like  : oursite.com/store/product-launch
    Replicate for store_file html

Product Detail Page:
31. We aim to have oursite.com/our_product
    app_store path('<slug:category_slug>/<slug:product_slug>', views.product_detail_view, name = 'product_detail_path')
    Within product detail page, we are going to query the database to display dynamic info about product.
    We're going to do this from product_detail_view in app_store.views.
    "category__slug" returns slug value from category table

32. Link product detail from product card in home : Dynamic Link to our Django projects
    In app_store.models.py we define get_url
    In home.html we replace links

We should block add to card button for products without stock
33. In product detail file if stock < 0 then raise error

Create Shopping Cart : app_carts
34: we are going to work with a new app to manage the shopping cart.
    python manage.py startapp app_carts
    settings.py -> INSTALLED_APPS
    We implement a template for cart and insert it into cart.html
    We've to create : structure, columns and tables to host our shopping cart
    models.py -> CartClass and CartItemClass
    app_carts.admin.py register models
    Migrate! -> python manage.py migrate , makemigrations

Create shopping Cart and "add to cart" functionality
  We need to create records in database when user add products to shopping cart.
  This means we'll need to create records for CartClass and CartItemClass
35. In app_carts.views.py , we import app_store.models ProductClass and define add_cart_view
  In the add_cart_view function, the try blocks are used to handle the case where
    the cart or cart item for the current session does not exist in the database.
  This is important because if these objects do not exist, calling the get method
    on them will raise a DoesNotExist exception, which needs to be handled.
  The first try block handles the case where the cart does not exist, and the second
    try block handles the case where the cart item for the specified product does not exist
36. We need to create the path in app_carts.urls.py

Shopping Cart Dynamic Extract info from database and its items
37. In app_carts.views.py we improve cart_view which will send information to store/cart.html
    The file store/cart.html should receive the dictionary and display its items
    We will do that with
      {% for cart_item in cart_items  %}
      which will fill
      {{ cart_item.product.product_name }}
We want to display sub total price in shopping cart, we add that logic as method in models.py
38.  def subtotal() -> price *

Add total price and tax to shopping cart
39.  app_carts views.py -> def cart_view()
     We need to declare those new values in our dictionary -> context_to_send
     And update our cart html file

Within cart we have some buttons with functionalities: add products, reduce products..
  We are going to add + - functionality
40. Replace :
  <button class="btn btn-light" type="button" id="button-plus"> <i class="fa fa-minus"></i> </button>
  for :
  <a href="{% url 'add_cart_view_path' cart_item.product.id  %}" class .... </a>

  To reduce quantity, we need to define new function
41. in app_cart -> Views.py
    def remove_item_from_cart()
    We need to create a path for this function -> app_cart.urls.py
    path('remove_cart/<int:product_id>',views.remove_item_from_cart, name='remove_cart_view_path'),

We Want to be able to delete one product from the cart. We've a button in our html, lets create the functionality
42. In app_cart views.py -> def remove_item_from_cart
    (same first lines as remove_item_from_cart)
    add the path in urls file

ShoppingCart : Empty cart
43. In cart html : div class row only show if we have products
    we use {% if we have products %}

--- functionality fix --- -> include dynamic link in store html, navbar and home

Product Contained in ShoppingCart
44. In app_store views.py we look for cart id , if exist, we use it, if not, we create a new one

We want to display the number of items in the shoppingCart (present in the navbar)
45. In app_carts we create a new file : context_processors
    In settings.py TEMPLATES we include 'app_carts.context_processors.counter'
    In templates/includes/navbar we use {{ cart_items_count }}
    {{ cart_items_count }} is a dictionary, globaly available thanks to context_processors
    and registering it in TEMPLATES

Ecommerce pagination: Group results, and being able to get every group.
  We want to edit those groups and how we show it. i.e : In /sore we show a list
  of products with some condition -> show X products per "group". Each "group" is
  contained in a "page" and we have a bar with 1,2,3,4..
46. In app_store views: we import django.core.paginator
    We implement Paginator(products_available, 5)
How user can request differents "groups"/"pages"? In the path-url it'll be included
the "page", and we get that page number from the request
    page_requested = request.GET.get('page')
    paged_products = paginator.get_page(page_requested)
And finally, we need to send this products to the front end, we're using
context dictionary to do this.
    info_to_render = {
        'products_available' : paged_products,
        'product_count' : product_count}

We want to manage pagination from the index box [1,2,3] And display it only if
we've more than one page
47. In templates/store/store file
    We can access our dictionary from app_store.views.py -> products_available
    And we check has_other_pages from Paginator
    {% if products_available.has_other_pages %}
How many pages are we displaying in index box ? Is harcoded, we'll implement
a for loop to check how many index do we have
48. In templates/store/store file -> {% for i in products_available.paginator.page_range %}

Search for products!!  In the navbar we have a searchbox
49. Register the path in app_store urls.py
    path('search/', views.search_view, name='search_view_path')
    Create the new view in app_store views.py named search_view
    We need to import from django.db.models import Q as we want to match product name and description
    filter(Q(description__icontains=keyword)|Q(product_name__icontains=keyword))
    we send the results with info_to_render dictionary
In the front end we need to access this functionality
50. Within the navbar we have a form which action has to be execute search_view
    User's input will be register with "name" within the input tag. That name (keyword)
    will be used to filter our results in Q(... =keyword)
Add logic when we have no products
51. In store_file.html we implement a {% if we have products %}

Our Services/Product can have different variants : Company size, Language,
size, color, and so on...
Working with Variants in ecommerce:
52. Prepare the front end to interact with different variants.
    In product_detail_file.html we replace simple button for a form. This will allow
    us to send more information in the request

53. In ... /models.py we create the VariantClass
